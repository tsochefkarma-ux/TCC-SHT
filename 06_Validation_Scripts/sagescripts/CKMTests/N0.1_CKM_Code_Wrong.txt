cat > ckm_analysis.sage << 'EOF'
print("="*70)
print("CKM MATRIX FROM SCHOEN MANIFOLD")
print("="*70)

# Our framework values
A_framework = float((-25 + sqrt(653))/2)  # 0.277
lambda_1 = float(sqrt(A_framework))        # 0.526
lambda_2 = lambda_1 * float(sqrt(3))       # 0.911
kappa = [9, 3, 3]
kappa_123 = 27

print(f"\nFRAMEWORK VALUES:")
print(f"  A = {A_framework:.6f}")
print(f"  λ₁ = {lambda_1:.6f}")
print(f"  λ₂ = λ₃ = {lambda_2:.6f}")

# PDG values for CKM (2024)
lambda_W = 0.22500   # Wolfenstein λ (= sin θ_C)
A_W = 0.826          # Wolfenstein A
rho_W = 0.159        # Wolfenstein ρ̄
eta_W = 0.348        # Wolfenstein η̄

print(f"\nPDG WOLFENSTEIN PARAMETERS:")
print(f"  λ = {lambda_W}")
print(f"  A = {A_W}")
print(f"  ρ̄ = {rho_W}")
print(f"  η̄ = {eta_W}")

# CKM magnitudes
V_us = lambda_W                           # ≈ 0.225
V_cb = A_W * lambda_W**2                  # ≈ 0.042
V_ub = A_W * lambda_W**3 * float(sqrt(rho_W**2 + eta_W**2))  # ≈ 0.004

print(f"\nCKM MAGNITUDES (PDG):")
print(f"  |V_us| = {V_us:.4f}")
print(f"  |V_cb| = {V_cb:.4f}")
print(f"  |V_ub| = {V_ub:.5f}")

print("\n" + "="*70)
print("TESTING RELATIONSHIPS")
print("="*70)

# 1. Cabibbo angle (already established)
sin_theta_C = lambda_1/float(sqrt(6)) * (1 + A_framework/6)
print(f"\n1. CABIBBO ANGLE (λ):")
print(f"   Predicted: sin θ_C = {sin_theta_C:.4f}")
print(f"   Observed:  λ = {lambda_W:.4f}")
print(f"   Agreement: {100*(1 - abs(sin_theta_C - lambda_W)/lambda_W):.2f}%")

# 2. Can we get A_Wolfenstein?
# Hypothesis: V_cb ≈ α_GUT = A_framework/7
alpha_GUT = A_framework / 7
print(f"\n2. V_cb FROM α_GUT:")
print(f"   Predicted: V_cb ≈ α_GUT = {alpha_GUT:.4f}")
print(f"   Observed:  V_cb = {V_cb:.4f}")
print(f"   Agreement: {100*(1 - abs(alpha_GUT - V_cb)/V_cb):.1f}%")

# This gives A_Wolfenstein
A_W_pred = alpha_GUT / sin_theta_C**2
print(f"\n   → A_Wolfenstein = V_cb/λ² = {A_W_pred:.3f}")
print(f"   Observed: A = {A_W:.3f}")
print(f"   Agreement: {100*(1 - abs(A_W_pred - A_W)/A_W):.1f}%")

# 3. Alternative: use eigenvalue ratios
print(f"\n3. EIGENVALUE RATIO APPROACH:")
print(f"   λ₂/λ₁ = √3 = {lambda_2/lambda_1:.4f}")
print(f"   (λ₁/λ₂)² = 1/3 = {(lambda_1/lambda_2)**2:.4f}")

# V_cb from λ₂?
V_cb_test1 = lambda_2 / kappa_123
V_cb_test2 = lambda_1 * lambda_2 / kappa_123
print(f"   λ₂/κ₁₂₃ = {V_cb_test1:.4f} (compare V_cb = {V_cb:.4f})")

# 4. V_ub (smallest element)
print(f"\n4. V_ub (1-3 mixing):")
V_ub_pred = alpha_GUT * sin_theta_C  # = λ₁² × λ / 7
print(f"   Predicted: V_ub ≈ α_GUT × λ = {V_ub_pred:.5f}")
print(f"   Observed:  V_ub = {V_ub:.5f}")
print(f"   Ratio: {V_ub/V_ub_pred:.2f}")

# Alternative V_ub
V_ub_pred2 = lambda_1**3 / 7
print(f"   Alternative: λ₁³/7 = {V_ub_pred2:.5f}")

# 5. CP violation (η)
print(f"\n5. CP VIOLATION (η):")
print(f"   Z₃ phase: arg(τ) = 2π/3 = 120°")
delta_CKM = float(arctan(eta_W/rho_W) * 180/pi)
print(f"   CKM phase: δ = arctan(η/ρ) = {delta_CKM:.1f}°")

# The Z₃×Z₃ structure gives discrete phases
# τ = e^{2πi/3} has phase 120°
# Maybe δ_CKM relates to this?
phase_ratio = delta_CKM / 120
print(f"   Ratio δ/120° = {phase_ratio:.3f}")

# Jarlskog invariant
J_obs = 3.0e-5
J_pred = sin_theta_C**2 * V_cb * V_ub * eta_W
print(f"\n   Jarlskog invariant:")
print(f"   J_observed ≈ 3×10⁻⁵")

print("\n" + "="*70)
print("SUMMARY: CKM FROM λ₁")
print("="*70)
print(f"""
ESTABLISHED:
  λ (Cabibbo) = λ₁/√6 × (1 + λ₁²/6) = {sin_theta_C:.4f} ✓

PROMISING:
  A ≈ (α_GUT)/λ² = (λ₁²/7)/λ² = {A_W_pred:.3f} (obs: {A_W})
  V_cb ≈ α_GUT = λ₁²/7 = {alpha_GUT:.4f} (obs: {V_cb:.4f})

NEEDS WORK:
  ρ, η (CP violation) - may require Z₃×Z₃ phase structure
  
PATTERN:
  V_us ~ λ₁/√6 (1st-2nd generation)
  V_cb ~ λ₁²/7 (2nd-3rd generation)  
  V_ub ~ λ₁³/? (1st-3rd generation)
  
  This suggests: V_ij ~ λ₁^|i-j| / (normalization)
""")
EOF
sage ckm_analysis.sage